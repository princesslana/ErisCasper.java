<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JDABuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ErisCasper.java</a> &gt; <a href="index.source.html" class="el_package">net.dv8tion.jda.core</a> &gt; <span class="el_source">JDABuilder.java</span></div><h1>JDABuilder.java</h1><pre class="source lang-java linenums">/*
 *     Copyright 2015-2018 Austin Keener &amp; Michael Ritter &amp; Florian Spie√ü
 *     Copyright 2018-2018 &quot;Princess&quot; Lana Samson
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.dv8tion.jda.core;

import com.neovisionaries.ws.client.WebSocketFactory;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ConcurrentMap;
import javax.security.auth.login.LoginException;
import net.dv8tion.jda.core.JDA.Status;
import net.dv8tion.jda.core.entities.Game;
import net.dv8tion.jda.core.entities.impl.JDAImpl;
import net.dv8tion.jda.core.exceptions.AccountTypeException;
import net.dv8tion.jda.core.hooks.IEventManager;
import net.dv8tion.jda.core.managers.impl.PresenceImpl;
import net.dv8tion.jda.core.utils.Checks;
import net.dv8tion.jda.core.utils.SessionController;
import net.dv8tion.jda.core.utils.SessionControllerAdapter;
import okhttp3.OkHttpClient;

/**
 * Used to create new {@link net.dv8tion.jda.core.JDA} instances. This is also useful for making
 * sure all of your {@link net.dv8tion.jda.core.hooks.EventListener EventListeners} are registered
 * before {@link net.dv8tion.jda.core.JDA} attempts to log in.
 *
 * &lt;p&gt;A single JDABuilder can be reused multiple times. Each call to {@link
 * net.dv8tion.jda.core.JDABuilder#buildAsync() buildAsync()} or {@link
 * net.dv8tion.jda.core.JDABuilder#buildBlocking() buildBlocking()} creates a new {@link
 * net.dv8tion.jda.core.JDA} instance using the same information. This means that you can have
 * listeners easily registered to multiple {@link net.dv8tion.jda.core.JDA} instances.
 */
public class JDABuilder {
  protected final List&lt;Object&gt; listeners;

<span class="nc" id="L51">  protected ConcurrentMap&lt;String, String&gt; contextMap = null;</span>
<span class="nc" id="L52">  protected boolean enableContext = true;</span>
<span class="nc" id="L53">  protected SessionController controller = null;</span>
<span class="nc" id="L54">  protected OkHttpClient.Builder httpClientBuilder = null;</span>
<span class="nc" id="L55">  protected WebSocketFactory wsFactory = null;</span>
  protected AccountType accountType;
<span class="nc" id="L57">  protected String token = null;</span>
<span class="nc" id="L58">  protected IEventManager eventManager = null;</span>
<span class="nc" id="L59">  protected JDA.ShardInfo shardInfo = null;</span>
<span class="nc" id="L60">  protected Game game = null;</span>
<span class="nc" id="L61">  protected OnlineStatus status = OnlineStatus.ONLINE;</span>
<span class="nc" id="L62">  protected int maxReconnectDelay = 900;</span>
<span class="nc" id="L63">  protected int corePoolSize = 2;</span>
<span class="nc" id="L64">  protected boolean enableVoice = true;</span>
<span class="nc" id="L65">  protected boolean enableShutdownHook = true;</span>
<span class="nc" id="L66">  protected boolean enableBulkDeleteSplitting = true;</span>
<span class="nc" id="L67">  protected boolean autoReconnect = true;</span>
<span class="nc" id="L68">  protected boolean idle = false;</span>
<span class="nc" id="L69">  protected boolean requestTimeoutRetry = true;</span>

  /**
   * Creates a completely empty JDABuilder. &lt;br&gt;
   * If you use this, you need to set the token using {@link
   * net.dv8tion.jda.core.JDABuilder#setToken(String) setToken(String)} before calling {@link
   * net.dv8tion.jda.core.JDABuilder#buildAsync() buildAsync()} or {@link
   * net.dv8tion.jda.core.JDABuilder#buildBlocking() buildBlocking()}
   *
   * @param accountType The {@link net.dv8tion.jda.core.AccountType AccountType}.
   * @throws IllegalArgumentException If the given AccountType is {@code null}
   */
<span class="nc" id="L81">  public JDABuilder(AccountType accountType) {</span>
<span class="nc" id="L82">    Checks.notNull(accountType, &quot;accountType&quot;);</span>

<span class="nc" id="L84">    this.accountType = accountType;</span>
<span class="nc" id="L85">    this.listeners = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L86">  }</span>

  /**
   * Sets the {@link org.slf4j.MDC MDC} mappings to use in JDA. &lt;br&gt;
   * If sharding is enabled JDA will automatically add a {@code jda.shard} context with the format
   * {@code [SHARD_ID / TOTAL]} where {@code SHARD_ID} and {@code TOTAL} are the shard
   * configuration. Additionally it will provide context for the id via {@code jda.shard.id} and the
   * total via {@code jda.shard.total}.
   *
   * &lt;p&gt;If provided with non-null map this automatically enables MDC context using {@link
   * #setContextEnabled(boolean) setContextEnable(true)}!
   *
   * @param map The &lt;b&gt;modifiable&lt;/b&gt; context map to use in JDA, or {@code null} to reset
   * @return The JDABuilder instance. Useful for chaining.
   * @see &lt;a href=&quot;https://www.slf4j.org/api/org/slf4j/MDC.html&quot; target=&quot;_blank&quot;&gt;MDC Javadoc&lt;/a&gt;
   * @see #setContextEnabled(boolean)
   */
  public JDABuilder setContextMap(ConcurrentMap&lt;String, String&gt; map) {
<span class="nc" id="L104">    this.contextMap = map;</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">    if (map != null) this.enableContext = true;</span>
<span class="nc" id="L106">    return this;</span>
  }

  /**
   * Whether JDA should use a synchronized MDC context for all of its controlled threads. &lt;br&gt;
   * Default: {@code true}
   *
   * @param enable True, if JDA should provide an MDC context map
   * @return The JDABuilder instance. Useful for chaining.
   * @see &lt;a href=&quot;https://www.slf4j.org/api/org/slf4j/MDC.html&quot; target=&quot;_blank&quot;&gt;MDC Javadoc&lt;/a&gt;
   * @see #setContextMap(java.util.concurrent.ConcurrentMap)
   */
  public JDABuilder setContextEnabled(boolean enable) {
<span class="nc" id="L119">    this.enableContext = enable;</span>
<span class="nc" id="L120">    return this;</span>
  }

  /**
   * Whether the Requester should retry when a {@link java.net.SocketTimeoutException
   * SocketTimeoutException} occurs. &lt;br&gt;
   * &lt;b&gt;Default&lt;/b&gt;: {@code true}
   *
   * &lt;p&gt;This value can be changed at any time with {@link
   * net.dv8tion.jda.core.JDA#setRequestTimeoutRetry(boolean) JDA.setRequestTimeoutRetry(boolean)}!
   *
   * @param retryOnTimeout True, if the Request should retry once on a socket timeout
   * @return The JDABuilder instance. Useful for chaining.
   */
  public JDABuilder setRequestTimeoutRetry(boolean retryOnTimeout) {
<span class="nc" id="L135">    this.requestTimeoutRetry = retryOnTimeout;</span>
<span class="nc" id="L136">    return this;</span>
  }

  /**
   * Sets the token that will be used by the {@link net.dv8tion.jda.core.JDA} instance to log in
   * when {@link net.dv8tion.jda.core.JDABuilder#buildAsync() buildAsync()} or {@link
   * net.dv8tion.jda.core.JDABuilder#buildBlocking() buildBlocking()} is called.
   *
   * &lt;h2&gt;For {@link net.dv8tion.jda.core.AccountType#BOT}&lt;/h2&gt;
   *
   * &lt;ol&gt;
   *   &lt;li&gt;Go to your &lt;a href=&quot;https://discordapp.com/developers/applications/me&quot;&gt;Discord
   *       Applications&lt;/a&gt;
   *   &lt;li&gt;Create or select an already existing application
   *   &lt;li&gt;Verify that it has already been turned into a Bot. If you see the &quot;Create a Bot User&quot;
   *       button, click it.
   *   &lt;li&gt;Click the &lt;i&gt;click to reveal&lt;/i&gt; link beside the &lt;b&gt;Token&lt;/b&gt; label to show your Bot's
   *       {@code token}
   * &lt;/ol&gt;
   *
   * &lt;h2&gt;For {@link net.dv8tion.jda.core.AccountType#CLIENT}&lt;/h2&gt;
   *
   * &lt;br&gt;
   * Using either the Discord desktop app or the Browser Webapp
   *
   * &lt;ol&gt;
   *   &lt;li&gt;Press {@code Ctrl-Shift-i} which will bring up the developer tools.
   *   &lt;li&gt;Go to the {@code Application} tab
   *   &lt;li&gt;Under {@code Storage}, select {@code Local Storage}, and then {@code discordapp.com}
   *   &lt;li&gt;Find the {@code token} row and copy the value that is in quotes.
   * &lt;/ol&gt;
   *
   * @param token The token of the account that you would like to login with.
   * @return The JDABuilder instance. Useful for chaining.
   */
  public JDABuilder setToken(String token) {
<span class="nc" id="L172">    this.token = token;</span>
<span class="nc" id="L173">    return this;</span>
  }

  /**
   * Sets the {@link okhttp3.OkHttpClient.Builder Builder} that will be used by JDA's requester.
   * This can be used to set things such as connection timeout and proxy.
   *
   * @param builder The new {@link okhttp3.OkHttpClient.Builder Builder} to use.
   * @return The JDABuilder instance. Useful for chaining.
   */
  public JDABuilder setHttpClientBuilder(OkHttpClient.Builder builder) {
<span class="nc" id="L184">    this.httpClientBuilder = builder;</span>
<span class="nc" id="L185">    return this;</span>
  }

  /**
   * Sets the {@link com.neovisionaries.ws.client.WebSocketFactory WebSocketFactory} that will be
   * used by JDA's websocket client. This can be used to set things such as connection timeout and
   * proxy.
   *
   * @param factory The new {@link com.neovisionaries.ws.client.WebSocketFactory WebSocketFactory}
   *     to use.
   * @return The JDABuilder instance. Useful for chaining.
   */
  public JDABuilder setWebsocketFactory(WebSocketFactory factory) {
<span class="nc" id="L198">    this.wsFactory = factory;</span>
<span class="nc" id="L199">    return this;</span>
  }

  /**
   * Sets the core pool size for the global JDA {@link java.util.concurrent.ScheduledExecutorService
   * ScheduledExecutorService} which is used in various locations throughout the JDA instance
   * created by this builder. (Default: 2)
   *
   * @param size The core pool size for the global JDA executor
   * @throws java.lang.IllegalArgumentException If the specified core pool size is not positive
   * @return The JDABuilder instance. Useful for chaining.
   */
  public JDABuilder setCorePoolSize(int size) {
<span class="nc" id="L212">    Checks.positive(size, &quot;Core pool size&quot;);</span>
<span class="nc" id="L213">    this.corePoolSize = size;</span>
<span class="nc" id="L214">    return this;</span>
  }

  /**
   * Enables/Disables Voice functionality. &lt;br&gt;
   * This is useful, if your current system doesn't support Voice and you do not need it.
   *
   * &lt;p&gt;Default: &lt;b&gt;true (enabled)&lt;/b&gt;
   *
   * @param enabled True - enables voice support.
   * @return The JDABuilder instance. Useful for chaining.
   */
  public JDABuilder setAudioEnabled(boolean enabled) {
<span class="nc" id="L227">    this.enableVoice = enabled;</span>
<span class="nc" id="L228">    return this;</span>
  }

  /**
   * If enabled, JDA will separate the bulk delete event into individual delete events, but this
   * isn't as efficient as handling a single event would be. It is recommended that BulkDelete
   * Splitting be disabled and that the developer should instead handle the {@link
   * net.dv8tion.jda.core.events.message.MessageBulkDeleteEvent MessageBulkDeleteEvent}
   *
   * &lt;p&gt;Default: &lt;b&gt;true (enabled)&lt;/b&gt;
   *
   * @param enabled True - The MESSAGE_DELETE_BULK will be split into multiple individual
   *     MessageDeleteEvents.
   * @return The JDABuilder instance. Useful for chaining.
   */
  public JDABuilder setBulkDeleteSplittingEnabled(boolean enabled) {
<span class="nc" id="L244">    this.enableBulkDeleteSplitting = enabled;</span>
<span class="nc" id="L245">    return this;</span>
  }

  /**
   * Enables/Disables the use of a Shutdown hook to clean up JDA. &lt;br&gt;
   * When the Java program closes shutdown hooks are run. This is used as a last-second cleanup
   * attempt by JDA to properly close connections.
   *
   * &lt;p&gt;Default: &lt;b&gt;true (enabled)&lt;/b&gt;
   *
   * @param enable True (default) - use shutdown hook to clean up JDA if the Java program is closed.
   * @return Return the {@link net.dv8tion.jda.core.JDABuilder JDABuilder } instance. Useful for
   *     chaining.
   */
  public JDABuilder setEnableShutdownHook(boolean enable) {
<span class="nc" id="L260">    this.enableShutdownHook = enable;</span>
<span class="nc" id="L261">    return this;</span>
  }

  /**
   * Sets whether or not JDA should try to reconnect if a connection-error is encountered. &lt;br&gt;
   * This will use an incremental reconnect (timeouts are increased each time an attempt fails).
   *
   * &lt;p&gt;Default: &lt;b&gt;true (enabled)&lt;/b&gt;
   *
   * @param autoReconnect If true - enables autoReconnect
   * @return The JDABuilder instance. Useful for chaining.
   */
  public JDABuilder setAutoReconnect(boolean autoReconnect) {
<span class="nc" id="L274">    this.autoReconnect = autoReconnect;</span>
<span class="nc" id="L275">    return this;</span>
  }

  /**
   * Changes the internally used EventManager. &lt;br&gt;
   * There are 2 provided Implementations:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;{@link net.dv8tion.jda.core.hooks.InterfacedEventManager InterfacedEventManager} which
   *       uses the Interface {@link net.dv8tion.jda.core.hooks.EventListener EventListener} (tip:
   *       use the {@link net.dv8tion.jda.core.hooks.ListenerAdapter ListenerAdapter}). &lt;br&gt;
   *       This is the default EventManager.
   *   &lt;li&gt;{@link net.dv8tion.jda.core.hooks.AnnotatedEventManager AnnotatedEventManager} which uses
   *       the Annotation {@link net.dv8tion.jda.core.hooks.SubscribeEvent @SubscribeEvent} to mark
   *       the methods that listen for events.
   * &lt;/ul&gt;
   *
   * &lt;br&gt;
   * You can also create your own EventManager (See {@link
   * net.dv8tion.jda.core.hooks.IEventManager}).
   *
   * @param manager The new {@link net.dv8tion.jda.core.hooks.IEventManager} to use.
   * @return The JDABuilder instance. Useful for chaining.
   */
  public JDABuilder setEventManager(IEventManager manager) {
<span class="nc" id="L300">    this.eventManager = manager;</span>
<span class="nc" id="L301">    return this;</span>
  }

  /**
   * Sets whether or not we should mark our session as afk &lt;br&gt;
   * This value can be changed at any time in the {@link net.dv8tion.jda.core.managers.Presence
   * Presence} from a JDA instance.
   *
   * @param idle boolean value that will be provided with our IDENTIFY package to mark our session
   *     as afk or not. &lt;b&gt;(default false)&lt;/b&gt;
   * @return The JDABuilder instance. Useful for chaining.
   * @see net.dv8tion.jda.core.managers.Presence#setIdle(boolean) Presence#setIdle(boolean)
   */
  public JDABuilder setIdle(boolean idle) {
<span class="nc" id="L315">    this.idle = idle;</span>
<span class="nc" id="L316">    return this;</span>
  }

  /**
   * Sets the {@link net.dv8tion.jda.core.entities.Game Game} for our session. &lt;br&gt;
   * This value can be changed at any time in the {@link net.dv8tion.jda.core.managers.Presence
   * Presence} from a JDA instance.
   *
   * &lt;p&gt;&lt;b&gt;Hint:&lt;/b&gt; You can create a {@link net.dv8tion.jda.core.entities.Game Game} object using
   * {@link net.dv8tion.jda.core.entities.Game#playing(String)} or {@link
   * net.dv8tion.jda.core.entities.Game#streaming(String, String)}.
   *
   * @param game An instance of {@link net.dv8tion.jda.core.entities.Game Game} (null allowed)
   * @return The JDABuilder instance. Useful for chaining.
   * @see net.dv8tion.jda.core.managers.Presence#setGame(Game) Presence.setGame(Game)
   */
  public JDABuilder setGame(Game game) {
<span class="nc" id="L333">    this.game = game;</span>
<span class="nc" id="L334">    return this;</span>
  }

  /**
   * Sets the {@link net.dv8tion.jda.core.OnlineStatus OnlineStatus} our connection will display.
   * &lt;br&gt;
   * This value can be changed at any time in the {@link net.dv8tion.jda.core.managers.Presence
   * Presence} from a JDA instance.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt;This will not take affect for {@link net.dv8tion.jda.core.AccountType#CLIENT
   * AccountType.CLIENT} if the status specified in the user_settings is not &quot;online&quot; as it is
   * overriding our identify status.
   *
   * @param status Not-null OnlineStatus (default online)
   * @throws IllegalArgumentException if the provided OnlineStatus is null or {@link
   *     net.dv8tion.jda.core.OnlineStatus#UNKNOWN UNKNOWN}
   * @return The JDABuilder instance. Useful for chaining.
   * @see net.dv8tion.jda.core.managers.Presence#setStatus(OnlineStatus)
   *     Presence.setStatus(OnlineStatus)
   */
  public JDABuilder setStatus(OnlineStatus status) {
<span class="nc bnc" id="L355" title="All 4 branches missed.">    if (status == null || status == OnlineStatus.UNKNOWN)</span>
<span class="nc" id="L356">      throw new IllegalArgumentException(&quot;OnlineStatus cannot be null or unknown!&quot;);</span>
<span class="nc" id="L357">    this.status = status;</span>
<span class="nc" id="L358">    return this;</span>
  }

  /**
   * Adds all provided listeners to the list of listeners that will be used to populate the {@link
   * net.dv8tion.jda.core.JDA JDA} object. &lt;br&gt;
   * This uses the {@link net.dv8tion.jda.core.hooks.InterfacedEventManager InterfacedEventListener}
   * by default. &lt;br&gt;
   * To switch to the {@link net.dv8tion.jda.core.hooks.AnnotatedEventManager
   * AnnotatedEventManager}, use {@link #setEventManager(net.dv8tion.jda.core.hooks.IEventManager)
   * setEventManager(new AnnotatedEventManager())}.
   *
   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; When using the {@link net.dv8tion.jda.core.hooks.InterfacedEventManager
   * InterfacedEventListener} (default), given listener(s) &lt;b&gt;must&lt;/b&gt; be instance of {@link
   * net.dv8tion.jda.core.hooks.EventListener EventListener}!
   *
   * @param listeners The listener(s) to add to the list.
   * @throws java.lang.IllegalArgumentException If either listeners or one of it's objects is {@code
   *     null}.
   * @return The JDABuilder instance. Useful for chaining.
   * @see net.dv8tion.jda.core.JDA#addEventListener(Object...) JDA.addEventListener(Object...)
   */
  public JDABuilder addEventListener(Object... listeners) {
<span class="nc" id="L381">    Checks.noneNull(listeners, &quot;listeners&quot;);</span>

<span class="nc" id="L383">    Collections.addAll(this.listeners, listeners);</span>
<span class="nc" id="L384">    return this;</span>
  }

  /**
   * Removes all provided listeners from the list of listeners.
   *
   * @param listeners The listener(s) to remove from the list.
   * @throws java.lang.IllegalArgumentException If either listeners or one of it's objects is {@code
   *     null}.
   * @return The JDABuilder instance. Useful for chaining.
   * @see net.dv8tion.jda.core.JDA#removeEventListener(Object...) JDA.removeEventListener(Object...)
   */
  public JDABuilder removeEventListener(Object... listeners) {
<span class="nc" id="L397">    Checks.noneNull(listeners, &quot;listeners&quot;);</span>

<span class="nc" id="L399">    this.listeners.removeAll(Arrays.asList(listeners));</span>
<span class="nc" id="L400">    return this;</span>
  }

  /**
   * Sets the maximum amount of time that JDA will back off to wait when attempting to reconnect the
   * MainWebsocket. &lt;br&gt;
   * Provided value must be 32 or greater.
   *
   * @param maxReconnectDelay The maximum amount of time that JDA will wait between reconnect
   *     attempts in seconds.
   * @throws java.lang.IllegalArgumentException Thrown if the provided {@code maxReconnectDelay} is
   *     less than 32.
   * @return The JDABuilder instance. Useful for chaining.
   */
  public JDABuilder setMaxReconnectDelay(int maxReconnectDelay) {
<span class="nc bnc" id="L415" title="All 2 branches missed.">    Checks.check(</span>
        maxReconnectDelay &gt;= 32,
        &quot;Max reconnect delay must be 32 seconds or greater. You provided %d.&quot;,
<span class="nc" id="L418">        maxReconnectDelay);</span>

<span class="nc" id="L420">    this.maxReconnectDelay = maxReconnectDelay;</span>
<span class="nc" id="L421">    return this;</span>
  }

  /**
   * This will enable sharding mode for JDA. &lt;br&gt;
   * In sharding mode, guilds are split up and assigned one of multiple shards (clients). &lt;br&gt;
   * The shardId that receives all stuff related to given bot is calculated as follows: shardId ==
   * (guildId {@literal &gt;&gt;} 22) % shardTotal; &lt;br&gt;
   * &lt;b&gt;PMs are only sent to shard 0.&lt;/b&gt;
   *
   * &lt;p&gt;Please note, that a shard will not know about guilds which are not assigned to it.
   *
   * &lt;p&gt;&lt;b&gt;It is not possible to use sharding with an account for {@link
   * net.dv8tion.jda.core.AccountType#CLIENT AccountType.CLIENT}!&lt;/b&gt;
   *
   * @param shardId The id of this shard (starting at 0).
   * @param shardTotal The number of overall shards.
   * @throws net.dv8tion.jda.core.exceptions.AccountTypeException If this is used on a JDABuilder
   *     for {@link net.dv8tion.jda.core.AccountType#CLIENT AccountType.CLIENT}
   * @throws java.lang.IllegalArgumentException If the provided shard configuration is invalid
   *     ({@code 0 &lt;= shardId &lt; shardTotal} with {@code shardTotal &gt; 0})
   * @return The JDABuilder instance. Useful for chaining.
   * @see net.dv8tion.jda.core.JDA#getShardInfo() JDA.getShardInfo()
   * @see net.dv8tion.jda.bot.sharding.ShardManager ShardManager
   */
  public JDABuilder useSharding(int shardId, int shardTotal) {
<span class="nc" id="L447">    AccountTypeException.check(accountType, AccountType.BOT);</span>
<span class="nc" id="L448">    Checks.notNegative(shardId, &quot;Shard ID&quot;);</span>
<span class="nc" id="L449">    Checks.positive(shardTotal, &quot;Shard Total&quot;);</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">    Checks.check(</span>
        shardId &lt; shardTotal,
        &quot;The shard ID must be lower than the shardTotal! Shard IDs are 0-based.&quot;);
<span class="nc" id="L453">    shardInfo = new JDA.ShardInfo(shardId, shardTotal);</span>
<span class="nc" id="L454">    return this;</span>
  }

  /**
   * Sets the {@link net.dv8tion.jda.core.utils.SessionController SessionController} for this
   * JDABuilder instance. This can be used to sync behaviour and state between shards of a bot and
   * should be one and the same instance on all builders for the shards. &lt;br&gt;
   * When {@link #useSharding(int, int)} is enabled, this is set by default.
   *
   * &lt;p&gt;When set, this allows the builder to build shards with respect to the login ratelimit
   * automatically.
   *
   * @param controller The {@link net.dv8tion.jda.core.utils.SessionController SessionController} to
   *     use
   * @return The JDABuilder instance. Useful for chaining.
   * @see net.dv8tion.jda.core.utils.SessionControllerAdapter SessionControllerAdapter
   */
  public JDABuilder setSessionController(SessionController controller) {
<span class="nc" id="L472">    this.controller = controller;</span>
<span class="nc" id="L473">    return this;</span>
  }

  /**
   * Builds a new {@link net.dv8tion.jda.core.JDA} instance and uses the provided token to start the
   * login process. &lt;br&gt;
   * The login process runs in a different thread, so while this will return immediately, {@link
   * net.dv8tion.jda.core.JDA} has not finished loading, thus many {@link net.dv8tion.jda.core.JDA}
   * methods have the chance to return incorrect information. &lt;br&gt;
   * The main use of this method is to start the JDA connect process and do other things in parallel
   * while startup is being performed like database connection or local resource loading.
   *
   * &lt;p&gt;If you wish to be sure that the {@link net.dv8tion.jda.core.JDA} information is correct,
   * please use {@link net.dv8tion.jda.core.JDABuilder#buildBlocking() buildBlocking()} or register
   * an {@link net.dv8tion.jda.core.hooks.EventListener EventListener} to listen for the {@link
   * net.dv8tion.jda.core.events.ReadyEvent ReadyEvent} .
   *
   * @throws LoginException If the provided token is invalid.
   * @throws IllegalArgumentException If the provided token is empty or null.
   * @return A {@link net.dv8tion.jda.core.JDA} instance that has started the login process. It is
   *     unknown as to whether or not loading has finished when this returns.
   */
  public JDA buildAsync() throws LoginException {
<span class="nc bnc" id="L496" title="All 2 branches missed.">    OkHttpClient.Builder httpClientBuilder =</span>
        this.httpClientBuilder == null ? new OkHttpClient.Builder() : this.httpClientBuilder;
<span class="nc bnc" id="L498" title="All 2 branches missed.">    WebSocketFactory wsFactory = this.wsFactory == null ? new WebSocketFactory() : this.wsFactory;</span>

<span class="nc bnc" id="L500" title="All 4 branches missed.">    if (controller == null &amp;&amp; shardInfo != null) controller = new SessionControllerAdapter();</span>

<span class="nc" id="L502">    JDAImpl jda =</span>
        new JDAImpl(
            accountType,
            token,
            controller,
            httpClientBuilder,
            wsFactory,
            autoReconnect,
            enableVoice,
            enableShutdownHook,
            enableBulkDeleteSplitting,
            requestTimeoutRetry,
            enableContext,
            corePoolSize,
            maxReconnectDelay,
            contextMap);

<span class="nc bnc" id="L519" title="All 2 branches missed.">    if (eventManager != null) jda.setEventManager(eventManager);</span>

<span class="nc" id="L521">    listeners.forEach(jda::addEventListener);</span>
<span class="nc" id="L522">    jda.setStatus(</span>
        JDA.Status
            .INITIALIZED); // This is already set by JDA internally, but this is to make sure the
    // listeners catch it.

<span class="nc" id="L527">    String gateway = jda.getGateway();</span>

    // Set the presence information before connecting to have the correct information ready when
    // sending IDENTIFY
<span class="nc" id="L531">    ((PresenceImpl) jda.getPresence()).setCacheGame(game).setCacheIdle(idle).setCacheStatus(status);</span>
<span class="nc" id="L532">    jda.login(gateway, shardInfo);</span>
<span class="nc" id="L533">    return jda;</span>
  }

  /**
   * Builds a new {@link net.dv8tion.jda.core.JDA} instance and uses the provided token to start the
   * login process. &lt;br&gt;
   * This method will block until JDA has reached the specified connection status.
   *
   * &lt;h2&gt;Login Cycle&lt;/h2&gt;
   *
   * &lt;ol&gt;
   *   &lt;li&gt;{@link net.dv8tion.jda.core.JDA.Status#INITIALIZING INITIALIZING}
   *   &lt;li&gt;{@link net.dv8tion.jda.core.JDA.Status#INITIALIZED INITIALIZED}
   *   &lt;li&gt;{@link net.dv8tion.jda.core.JDA.Status#LOGGING_IN LOGGING_IN}
   *   &lt;li&gt;{@link net.dv8tion.jda.core.JDA.Status#CONNECTING_TO_WEBSOCKET CONNECTING_TO_WEBSOCKET}
   *   &lt;li&gt;{@link net.dv8tion.jda.core.JDA.Status#IDENTIFYING_SESSION IDENTIFYING_SESSION}
   *   &lt;li&gt;{@link net.dv8tion.jda.core.JDA.Status#AWAITING_LOGIN_CONFIRMATION
   *       AWAITING_LOGIN_CONFIRMATION}
   *   &lt;li&gt;{@link net.dv8tion.jda.core.JDA.Status#LOADING_SUBSYSTEMS LOADING_SUBSYSTEMS}
   *   &lt;li&gt;{@link net.dv8tion.jda.core.JDA.Status#CONNECTED CONNECTED}
   * &lt;/ol&gt;
   *
   * @param status The {@link JDA.Status Status} to wait for, once JDA has reached the specified
   *     stage of the startup cycle this method will return.
   * @throws LoginException If the provided token is invalid.
   * @throws IllegalArgumentException If the provided token is empty or {@code null} or the provided
   *     status is not part of the login cycle.
   * @throws InterruptedException If an interrupt request is received while waiting for {@link
   *     net.dv8tion.jda.core.JDA} to finish logging in. This would most likely be caused by a JVM
   *     shutdown request.
   * @return A {@link net.dv8tion.jda.core.JDA} Object that is &lt;b&gt;guaranteed&lt;/b&gt; to be logged in and
   *     finished loading.
   */
  public JDA buildBlocking(JDA.Status status) throws LoginException, InterruptedException {
<span class="nc" id="L567">    Checks.notNull(status, &quot;Status&quot;);</span>
<span class="nc" id="L568">    Checks.check(</span>
<span class="nc" id="L569">        status.isInit(),</span>
        &quot;Cannot await the status %s as it is not part of the login cycle!&quot;,
        status);
<span class="nc" id="L572">    JDA jda = buildAsync();</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">    while (!jda.getStatus().isInit() // JDA might disconnect while starting</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">        || jda.getStatus().ordinal() &lt; status.ordinal()) // Wait until status is bypassed</span>
    {
<span class="nc bnc" id="L576" title="All 2 branches missed.">      if (jda.getStatus() == Status.SHUTDOWN)</span>
<span class="nc" id="L577">        throw new IllegalStateException(&quot;JDA was unable to finish starting up!&quot;);</span>
<span class="nc" id="L578">      Thread.sleep(50);</span>
    }

<span class="nc" id="L581">    return jda;</span>
  }

  /**
   * Builds a new {@link net.dv8tion.jda.core.JDA} instance and uses the provided token to start the
   * login process. &lt;br&gt;
   * This method will block until JDA has logged in and finished loading all resources. This is an
   * alternative to using {@link net.dv8tion.jda.core.events.ReadyEvent ReadyEvent}.
   *
   * @throws LoginException If the provided token is invalid.
   * @throws IllegalArgumentException If the provided token is empty or null.
   * @throws InterruptedException If an interrupt request is received while waiting for {@link
   *     net.dv8tion.jda.core.JDA} to finish logging in. This would most likely be caused by a JVM
   *     shutdown request.
   * @return A {@link net.dv8tion.jda.core.JDA} Object that is &lt;b&gt;guaranteed&lt;/b&gt; to be logged in and
   *     finished loading.
   */
  public JDA buildBlocking() throws LoginException, InterruptedException {
<span class="nc" id="L599">    return buildBlocking(Status.CONNECTED);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>